/**
 * @fileoverview Pure-logic planner that builds pending channel list from config.
 * @module core/channel-setup/ChannelSetupPlanner
 * @version 1.0.0
 */

import type {
    ChannelSetupConfig,
    ChannelSetupEstimates,
} from './types';
import type {
    PlexLibraryType,
    PlexMediaItem,
    PlexCollection,
    PlexPlaylist,
    PlexTagDirectoryItem,
} from '../../modules/plex/library';
import type {
    ChannelConfig,
    ContentFilter,
    SortOrder,
    BuildStrategy,
} from '../../modules/scheduler/channel-manager';

export type PendingChannel = {
    name: string;
    contentSource: ChannelConfig['contentSource'];
    playbackMode: ChannelConfig['playbackMode'];
    shuffleSeed: number;
    contentFilters?: ContentFilter[];
    sortOrder?: SortOrder;
    isAutoGenerated?: boolean;
    buildStrategy?: BuildStrategy;
    sourceLibraryId?: string;
    sourceLibraryName?: string;
};

export interface ChannelSetupPlanInput {
    config: ChannelSetupConfig;
    libraries: PlexLibraryType[];
    playlists: PlexPlaylist[];
    collectionsByLibraryId: Map<string, PlexCollection[]>;
    tagItemsByLibraryId: Map<string, PlexMediaItem[]>;
    scanItemsByLibraryId: Map<string, PlexMediaItem[]>;
    libraryItemCountById: Map<string, number | null>;
    actorsByLibraryId: Map<string, PlexTagDirectoryItem[]>;
    studiosByLibraryId: Map<string, PlexTagDirectoryItem[]>;
    warnings: string[];
    seedFor: (value: string) => number;
}

export interface ChannelSetupPlan {
    pendingChannels: PendingChannel[];
    estimates: ChannelSetupEstimates;
    warnings: string[];
    skipped: number;
    reachedMaxChannels: boolean;
}

export interface ChannelIdentityCandidate {
    contentSource: ChannelConfig['contentSource'];
    contentFilters?: ContentFilter[];
    sortOrder?: SortOrder;
    playbackMode: ChannelConfig['playbackMode'];
}

export interface ChannelDiffEntry {
    name: string;
    identityKey: string;
    channelId?: string;
    number?: number;
    isAutoGenerated?: boolean;
}

export interface ChannelDiffResult {
    created: ChannelDiffEntry[];
    removed: ChannelDiffEntry[];
    unchanged: ChannelDiffEntry[];
    matchedPairs: Array<{ existing: ChannelConfig; planned: PendingChannel }>;
    summary: { created: number; removed: number; unchanged: number };
    samples: { created: string[]; removed: string[]; unchanged: string[] };
}

const emptyEstimates = (): ChannelSetupEstimates => ({
    total: 0,
    collections: 0,
    libraryFallback: 0,
    playlists: 0,
    genres: 0,
    directors: 0,
    decades: 0,
    recentlyAdded: 0,
    studios: 0,
    actors: 0,
});

export function buildChannelSetupPlan(input: ChannelSetupPlanInput): ChannelSetupPlan {
    const {
        config,
        libraries,
        playlists,
        collectionsByLibraryId,
        tagItemsByLibraryId,
        scanItemsByLibraryId,
        libraryItemCountById,
        actorsByLibraryId,
        studiosByLibraryId,
        warnings,
        seedFor,
    } = input;

    const estimates = emptyEstimates();
    const pending: PendingChannel[] = [];
    let skipped = 0;
    let reachedMaxChannels = false;

    const requestedMax = Number.isFinite(config.maxChannels) ? config.maxChannels : 100;
    const effectiveMaxChannels = Math.max(1, Math.floor(requestedMax));
    const requestedMinItems = Number.isFinite(config.minItemsPerChannel) ? config.minItemsPerChannel : 10;
    const minItems = Math.max(1, Math.floor(requestedMinItems));

    const selectedLibraries = libraries
        .filter((lib) => config.selectedLibraryIds.includes(lib.id))
        .sort((a, b) => a.title.localeCompare(b.title));

    const tryAdd = (strategy: keyof ChannelSetupEstimates, channel: PendingChannel): boolean => {
        if (pending.length >= effectiveMaxChannels) {
            reachedMaxChannels = true;
            return false;
        }
        pending.push(channel);
        estimates[strategy] += 1;
        estimates.total += 1;
        return true;
    };

    const sortTags = (tags: PlexTagDirectoryItem[]): PlexTagDirectoryItem[] => {
        return [...tags].sort((a, b) => {
            const countDiff = (b.count || 0) - (a.count || 0);
            if (countDiff !== 0) return countDiff;
            return a.title.localeCompare(b.title);
        });
    };

    const countTags = (
        items: PlexMediaItem[],
        field: 'genres' | 'directors'
    ): { label: string; count: number }[] => {
        const counts = new Map<string, { label: string; count: number }>();
        for (const item of items) {
            const values = item[field];
            if (!values) continue;
            for (const value of values) {
                const trimmed = value.trim();
                if (!trimmed) continue;
                const key = trimmed.toLowerCase();
                const existing = counts.get(key);
                if (existing) {
                    existing.count++;
                } else {
                    counts.set(key, { label: trimmed, count: 1 });
                }
            }
        }
        return Array.from(counts.values()).sort((a, b) => a.label.localeCompare(b.label));
    };

    // 0. Server-wide Playlists
    if (config.enabledStrategies.playlists) {
        for (const pl of playlists) {
            if (pl.leafCount >= minItems) {
                if (!tryAdd('playlists', {
                    name: pl.title,
                    contentSource: {
                        type: 'playlist',
                        playlistKey: pl.ratingKey,
                        playlistName: pl.title,
                    },
                    playbackMode: 'shuffle',
                    shuffleSeed: seedFor(`playlist:${pl.ratingKey}`),
                    isAutoGenerated: true,
                    buildStrategy: 'playlists',
                })) {
                    break;
                }
            } else {
                skipped++;
            }
        }
    }

    const actorStudioCombineMode = config.actorStudioCombineMode ?? 'separate';

    for (const library of selectedLibraries) {
        // 1. Collections
        let addedCollections = false;
        if (config.enabledStrategies.collections) {
            const collections = collectionsByLibraryId.get(library.id) ?? [];
            for (const collection of collections) {
                if (collection.childCount >= minItems) {
                    if (!tryAdd('collections', {
                        name: collection.title,
                        contentSource: {
                            type: 'collection',
                            collectionKey: collection.ratingKey,
                            collectionName: collection.title,
                        },
                        playbackMode: 'shuffle',
                        shuffleSeed: seedFor(`collection:${collection.ratingKey}`),
                        isAutoGenerated: true,
                        buildStrategy: 'collections',
                        sourceLibraryId: library.id,
                        sourceLibraryName: library.title,
                    })) {
                        break;
                    }
                    addedCollections = true;
                } else {
                    skipped++;
                }
            }
        }

        if (!addedCollections && config.enabledStrategies.libraryFallback) {
            const fallbackCount = libraryItemCountById.get(library.id) ?? library.contentCount ?? null;
            if (fallbackCount === null || fallbackCount >= minItems) {
                tryAdd('libraryFallback', {
                    name: library.title,
                    contentSource: {
                        type: 'library',
                        libraryId: library.id,
                        libraryType: library.type === 'movie' ? 'movie' : 'show',
                        includeWatched: true,
                    },
                    playbackMode: 'shuffle',
                    shuffleSeed: seedFor(`library:${library.id}`),
                    isAutoGenerated: true,
                    buildStrategy: 'libraryFallback',
                    sourceLibraryId: library.id,
                    sourceLibraryName: library.title,
                });
            } else {
                skipped++;
            }
        } else if (!config.enabledStrategies.collections && !config.enabledStrategies.libraryFallback) {
            skipped++;
        }

        // 2. Recently Added
        if (config.enabledStrategies.recentlyAdded) {
            tryAdd('recentlyAdded', {
                name: `${library.title} - Recently Added`,
                contentSource: {
                    type: 'library',
                    libraryId: library.id,
                    libraryType: library.type === 'movie' ? 'movie' : 'show',
                    includeWatched: true,
                },
                sortOrder: 'added_desc',
                playbackMode: 'sequential',
                shuffleSeed: seedFor(`recentlyAdded:${library.id}`),
                isAutoGenerated: true,
                buildStrategy: 'recentlyAdded',
                sourceLibraryId: library.id,
                sourceLibraryName: library.title,
            });
        }

        // 3. Item Scanning Strategies
        if (config.enabledStrategies.genres || config.enabledStrategies.directors || config.enabledStrategies.decades) {
            const tagItems = tagItemsByLibraryId.get(library.id) ?? [];
            const scanItems = scanItemsByLibraryId.get(library.id) ?? [];

            if (config.enabledStrategies.genres) {
                const genres = countTags(tagItems, 'genres');
                for (const genre of genres) {
                    if (genre.count < minItems) continue;
                    if (!tryAdd('genres', {
                        name: `${library.title} - ${genre.label}`,
                        contentSource: {
                            type: 'library',
                            libraryId: library.id,
                            libraryType: library.type === 'movie' ? 'movie' : 'show',
                            includeWatched: true,
                        },
                        contentFilters: [{ field: 'genre', operator: 'eq', value: genre.label }],
                        playbackMode: 'shuffle',
                        shuffleSeed: seedFor(`genre:${library.id}:${genre.label}`),
                        isAutoGenerated: true,
                        buildStrategy: 'genres',
                        sourceLibraryId: library.id,
                        sourceLibraryName: library.title,
                    })) {
                        break;
                    }
                }
            }

            if (config.enabledStrategies.directors) {
                const directors = countTags(tagItems, 'directors');
                for (const director of directors) {
                    if (director.count < minItems) continue;
                    if (!tryAdd('directors', {
                        name: `${library.title} - ${director.label}`,
                        contentSource: {
                            type: 'library',
                            libraryId: library.id,
                            libraryType: library.type === 'movie' ? 'movie' : 'show',
                            includeWatched: true,
                        },
                        contentFilters: [{ field: 'director', operator: 'eq', value: director.label }],
                        playbackMode: 'shuffle',
                        shuffleSeed: seedFor(`director:${library.id}:${director.label}`),
                        isAutoGenerated: true,
                        buildStrategy: 'directors',
                        sourceLibraryId: library.id,
                        sourceLibraryName: library.title,
                    })) {
                        break;
                    }
                }
            }

            if (config.enabledStrategies.decades) {
                const decadeCounts = new Map<number, number>();
                for (const item of scanItems) {
                    if (item.year) {
                        const decade = Math.floor(item.year / 10) * 10;
                        decadeCounts.set(decade, (decadeCounts.get(decade) || 0) + 1);
                    }
                }
                const sortedDecades = Array.from(decadeCounts.keys()).sort((a, b) => a - b);
                for (const decade of sortedDecades) {
                    if ((decadeCounts.get(decade) || 0) < minItems) continue;
                    if (!tryAdd('decades', {
                        name: `${library.title} - ${decade}s`,
                        contentSource: {
                            type: 'library',
                            libraryId: library.id,
                            libraryType: library.type === 'movie' ? 'movie' : 'show',
                            includeWatched: true,
                        },
                        contentFilters: [
                            { field: 'year', operator: 'gte', value: decade },
                            { field: 'year', operator: 'lt', value: decade + 10 },
                        ],
                        playbackMode: 'shuffle',
                        shuffleSeed: seedFor(`decade:${library.id}:${decade}`),
                        isAutoGenerated: true,
                        buildStrategy: 'decades',
                        sourceLibraryId: library.id,
                        sourceLibraryName: library.title,
                    })) {
                        break;
                    }
                }
            }
        }
    }

    if (config.enabledStrategies.studios) {
        if (actorStudioCombineMode === 'combined') {
            const combined = combineTagSources(selectedLibraries, studiosByLibraryId, 'studio');
            for (const tag of combined) {
                if (tag.totalCount < minItems) continue;
                if (!tryAdd('studios', {
                    name: tag.title,
                    contentSource: {
                        type: 'mixed',
                        mixMode: 'sequential',
                        sources: tag.sources,
                    },
                    playbackMode: 'shuffle',
                    shuffleSeed: seedFor(`studio:${tag.key}`),
                    isAutoGenerated: true,
                    buildStrategy: 'studios',
                })) {
                    break;
                }
            }
        } else {
            for (const library of selectedLibraries) {
                const tags = sortTags(studiosByLibraryId.get(library.id) ?? []);
                for (const tag of tags) {
                    if (tag.count < minItems) continue;
                    if (!tryAdd('studios', {
                        name: `${tag.title} - ${library.type === 'movie' ? 'Movies' : 'TV'}`,
                        contentSource: {
                            type: 'library',
                            libraryId: library.id,
                            libraryType: library.type === 'movie' ? 'movie' : 'show',
                            includeWatched: true,
                            libraryFilter: buildTagFilter(tag, 'studio'),
                        },
                        playbackMode: 'shuffle',
                        shuffleSeed: seedFor(`studio:${library.id}:${tag.key}`),
                        isAutoGenerated: true,
                        buildStrategy: 'studios',
                        sourceLibraryId: library.id,
                        sourceLibraryName: library.title,
                    })) {
                        break;
                    }
                }
            }
        }
    }

    if (config.enabledStrategies.actors) {
        if (actorStudioCombineMode === 'combined') {
            const combined = combineTagSources(selectedLibraries, actorsByLibraryId, 'actor');
            for (const tag of combined) {
                if (tag.totalCount < minItems) continue;
                if (!tryAdd('actors', {
                    name: tag.title,
                    contentSource: {
                        type: 'mixed',
                        mixMode: 'sequential',
                        sources: tag.sources,
                    },
                    playbackMode: 'shuffle',
                    shuffleSeed: seedFor(`actor:${tag.key}`),
                    isAutoGenerated: true,
                    buildStrategy: 'actors',
                })) {
                    break;
                }
            }
        } else {
            for (const library of selectedLibraries) {
                const tags = sortTags(actorsByLibraryId.get(library.id) ?? []);
                for (const tag of tags) {
                    if (tag.count < minItems) continue;
                    if (!tryAdd('actors', {
                        name: `${tag.title} - ${library.type === 'movie' ? 'Movies' : 'TV'}`,
                        contentSource: {
                            type: 'library',
                            libraryId: library.id,
                            libraryType: library.type === 'movie' ? 'movie' : 'show',
                            includeWatched: true,
                            libraryFilter: buildTagFilter(tag, 'actor'),
                        },
                        playbackMode: 'shuffle',
                        shuffleSeed: seedFor(`actor:${library.id}:${tag.key}`),
                        isAutoGenerated: true,
                        buildStrategy: 'actors',
                        sourceLibraryId: library.id,
                        sourceLibraryName: library.title,
                    })) {
                        break;
                    }
                }
            }
        }
    }

    return {
        pendingChannels: pending,
        estimates,
        warnings: [...warnings],
        skipped,
        reachedMaxChannels,
    };
}

export function createChannelIdentityKey(candidate: ChannelIdentityCandidate): string {
    const normalized = {
        source: normalizeSource(candidate.contentSource),
        filters: normalizeFilters(candidate.contentFilters),
        sortOrder: candidate.sortOrder ?? null,
    };
    return stableStringify(normalized);
}

export function diffChannelPlans(
    existingChannels: ChannelConfig[],
    plannedChannels: PendingChannel[]
): ChannelDiffResult {
    const plannedByKey = new Map<string, PendingChannel[]>();
    for (const planned of plannedChannels) {
        const key = createChannelIdentityKey(planned);
        const list = plannedByKey.get(key) ?? [];
        list.push(planned);
        plannedByKey.set(key, list);
    }

    const created: ChannelDiffEntry[] = [];
    const removed: ChannelDiffEntry[] = [];
    const unchanged: ChannelDiffEntry[] = [];
    const matchedPairs: Array<{ existing: ChannelConfig; planned: PendingChannel }> = [];

    const consumePlanned = (key: string): PendingChannel | null => {
        const list = plannedByKey.get(key);
        if (!list || list.length === 0) return null;
        return list.shift() ?? null;
    };

    for (const existing of existingChannels) {
        const key = createChannelIdentityKey(existing);
        const planned = consumePlanned(key);
        if (planned) {
            matchedPairs.push({ existing, planned });
            const entry: ChannelDiffEntry = {
                name: existing.name,
                identityKey: key,
                channelId: existing.id,
                number: existing.number,
            };
            if (existing.isAutoGenerated !== undefined) {
                entry.isAutoGenerated = existing.isAutoGenerated;
            }
            unchanged.push(entry);
        } else {
            const entry: ChannelDiffEntry = {
                name: existing.name,
                identityKey: key,
                channelId: existing.id,
                number: existing.number,
            };
            if (existing.isAutoGenerated !== undefined) {
                entry.isAutoGenerated = existing.isAutoGenerated;
            }
            removed.push(entry);
        }
    }

    for (const [key, remaining] of plannedByKey.entries()) {
        for (const planned of remaining) {
            const entry: ChannelDiffEntry = {
                name: planned.name,
                identityKey: key,
            };
            if (planned.isAutoGenerated !== undefined) {
                entry.isAutoGenerated = planned.isAutoGenerated;
            }
            created.push(entry);
        }
    }

    const summary = {
        created: created.length,
        removed: removed.length,
        unchanged: unchanged.length,
    };
    const samples = {
        created: created.slice(0, 6).map((c) => c.name),
        removed: removed.slice(0, 6).map((c) => c.name),
        unchanged: unchanged.slice(0, 6).map((c) => c.name),
    };

    return { created, removed, unchanged, matchedPairs, summary, samples };
}

function buildTagFilter(tag: PlexTagDirectoryItem, type: 'actor' | 'studio'): Record<string, string | number> {
    if (tag.fastKey) {
        const parsed = parseFastKeyFilters(tag.fastKey);
        const hasActor = typeof parsed.actor === 'string' && parsed.actor.length > 0;
        const hasStudio = typeof parsed.studio === 'string' && parsed.studio.length > 0;
        if ((type === 'actor' && hasActor) || (type === 'studio' && hasStudio)) {
            return parsed;
        }
    }
    return { [type]: tag.key };
}

function parseFastKeyFilters(fastKey: string): Record<string, string | number> {
    try {
        const result: Record<string, string | number> = {};
        const url = new URL(fastKey, 'http://localhost');
        const allowList = new Set(['actor', 'studio', 'type']);
        for (const [rawKey, value] of url.searchParams.entries()) {
            if (!rawKey || value === '') continue;
            const key = rawKey.trim();
            const lowerKey = key.toLowerCase();
            if (/token/i.test(key)) continue;
            if (lowerKey.startsWith('x-plex-') || lowerKey.startsWith('x-plex-container-')) continue;
            if (!allowList.has(lowerKey)) continue;
            const trimmed = value.trim();
            if (!trimmed) continue;
            if (lowerKey === 'type') {
                const parsedType = Number.parseInt(trimmed, 10);
                if (Number.isFinite(parsedType)) {
                    result.type = parsedType;
                }
                continue;
            }
            if (lowerKey === 'actor') {
                result.actor = trimmed;
            }
            if (lowerKey === 'studio') {
                result.studio = trimmed;
            }
        }
        return result;
    } catch {
        return {};
    }
}

function combineTagSources(
    libraries: PlexLibraryType[],
    tagsByLibraryId: Map<string, PlexTagDirectoryItem[]>,
    type: 'actor' | 'studio'
): Array<{ key: string; title: string; totalCount: number; sources: ChannelConfig['contentSource'][] }> {
    const grouped = new Map<string, { title: string; totalCount: number; sources: ChannelConfig['contentSource'][] }>();

    for (const library of libraries) {
        const tags = tagsByLibraryId.get(library.id) ?? [];
        for (const tag of tags) {
            const groupKey = tag.title.trim().toLowerCase();
            if (!groupKey) continue;
            const entry = grouped.get(groupKey) ?? { title: tag.title, totalCount: 0, sources: [] };
            entry.totalCount += tag.count || 0;
            entry.sources.push({
                type: 'library',
                libraryId: library.id,
                libraryType: library.type === 'movie' ? 'movie' : 'show',
                includeWatched: true,
                libraryFilter: buildTagFilter(tag, type),
            });
            grouped.set(groupKey, entry);
        }
    }

    return Array.from(grouped.entries())
        .map(([key, entry]) => ({ key, title: entry.title, totalCount: entry.totalCount, sources: entry.sources }))
        .sort((a, b) => {
            const countDiff = b.totalCount - a.totalCount;
            if (countDiff !== 0) return countDiff;
            return a.title.localeCompare(b.title);
        });
}

function normalizeFilters(filters?: ContentFilter[]): Array<ContentFilter> | null {
    if (!filters || filters.length === 0) return null;
    return [...filters].sort((a, b) => {
        const aKey = `${a.field}:${a.operator}:${String(a.value)}`;
        const bKey = `${b.field}:${b.operator}:${String(b.value)}`;
        return aKey.localeCompare(bKey);
    });
}

function normalizeSource(source: ChannelConfig['contentSource']): unknown {
    switch (source.type) {
        case 'library':
            return {
                type: source.type,
                libraryId: source.libraryId,
                libraryType: source.libraryType,
                includeWatched: source.includeWatched,
                libraryFilter: normalizeRecord(source.libraryFilter),
            };
        case 'collection':
            return { type: source.type, collectionKey: source.collectionKey };
        case 'playlist':
            return { type: source.type, playlistKey: source.playlistKey };
        case 'show':
            return {
                type: source.type,
                showKey: source.showKey,
                seasonFilter: source.seasonFilter ? [...source.seasonFilter].sort((a, b) => a - b) : null,
            };
        case 'manual':
            return {
                type: source.type,
                items: [...source.items].sort((a, b) => a.ratingKey.localeCompare(b.ratingKey)),
            };
        case 'mixed': {
            const normalizedSources = source.sources.map(normalizeSource);
            const sortedSources = [...normalizedSources].sort((a, b) => stableStringify(a).localeCompare(stableStringify(b)));
            return { type: source.type, mixMode: source.mixMode, sources: sortedSources };
        }
        default:
            return source;
    }
}

function normalizeRecord(record?: Record<string, string | number>): Record<string, string | number> | null {
    if (!record) return null;
    const entries = Object.entries(record).sort(([a], [b]) => a.localeCompare(b));
    const normalized: Record<string, string | number> = {};
    for (const [key, value] of entries) {
        normalized[key] = value;
    }
    return normalized;
}

function stableStringify(value: unknown): string {
    if (value === null || typeof value !== 'object') {
        return JSON.stringify(value);
    }
    if (Array.isArray(value)) {
        return `[${value.map(stableStringify).join(',')}]`;
    }
    const obj = value as Record<string, unknown>;
    const keys = Object.keys(obj).sort();
    const entries = keys.map((key) => `${JSON.stringify(key)}:${stableStringify(obj[key])}`);
    return `{${entries.join(',')}}`;
}
